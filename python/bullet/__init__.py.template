import os.path
import types
import cppyy

_solib_name = "cppyy_bullet.so"

# First, create the 'bt' object, so that when we import other modules (such as
# 'bullet.callbacks', they can do 'from bullet import bt' too. (we'll populate
# BulletLibrary later)
class BulletLibrary (object):
    pass

bt = BulletLibrary()

__all__ = ['bt']

# Look for the shared library first in the same directory as __init__.py
# If it's not there, fall back to using the normal library search path instead.
_solib = os.path.join(os.path.dirname(__file__), _solib_name)
if not os.path.exists(_solib):
    _solib = _solib_name
cppyy.load_reflection_info(_solib)

_cppyy_syms = %SYMBOLS%

for symbol in _cppyy_syms:
    # We must use getattr first to prod cppyy into actually loading the
    # symbol into its dictionary...
    value = getattr(cppyy.gbl, symbol)

    # But for global variables, we actually want to look things up via raw
    # __dict__ access to make sure we copy the underlying property
    # (getter/setter) object instead of just the current value. (But just to
    # complicate things, some other types of symbols (i.e. typedefs) are never
    # actually present in the cppyy.gbl dictionary and can only be fetched via
    # getattr.  So try the dict lookup, and fall back to just using the value
    # we got from getattr above if that's not found..)
    vobj = cppyy.gbl.__dict__.get(symbol, value)

    # All these must be set on the BulletLibrary class, not the 'bt' object,
    # because properties (getters/setters) only work when defined on the class,
    # not the object.
    # However, if vobj is a function, then if we put it on the class, it will
    # end up being a bound method, which will change the arguments it gets
    # called with, and we don't want that.  In that case, we need to wrap it as
    # a staticmethod to avoid that.
    if isinstance(vobj, types.FunctionType):
        class_vobj = staticmethod(vobj)
    else:
        class_vobj = vobj
    setattr(BulletLibrary, symbol, class_vobj)

    # Also store them under "trimmed" names so that the user can refer to
    # things as (for example) "bt.DbvtBroadphase()" instead of
    # "bt.btDbvtBroadphase()"..
    if symbol.startswith('bt'):
        setattr(BulletLibrary, symbol[2:], class_vobj)
    elif symbol.startswith('BT_'):
        setattr(BulletLibrary, symbol[3:], class_vobj)

    # For classes and such, we will also define them in the 'bullet' module
    # itself (this is mainly so that the repr() returned for cppyy objects
    # (which reports them all as "bullet.<classname>") actually refers to a
    # valid thing).
    # Note: Due to limitations in the way modules work, we can't really do
    # getters/setters for anything directly in the 'bullet' module itself.  For
    # this reason, to avoid the potential for really nasty and confusing bugs
    # (by users who don't realize this), we won't even define anything in the
    # 'bullet' namespace that would require this functionality to work right
    # (so only stuff where getattr() and cppyy.gbl.__dict__ return the same
    # thing).
    if vobj == value:
        globals()[symbol] = vobj
        __all__.append(symbol)

from . import callbacks
BulletLibrary.gContactAddedCallback = callbacks.ContactAddedCallback()
BulletLibrary.gContactProcessedCallback = callbacks.ContactProcessedCallback()
BulletLibrary.gContactDestroyedCallback = callbacks.ContactDestroyedCallback()

